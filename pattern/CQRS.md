# CQRS 패턴

- 우리가 보통 이야기하는 CRUD(Create, Read, Update, Delete)에서 CUD(Command)와 R(Query)을 구분하자는 이야기다.
- 구분하는 이유는,우리가 Database로부터 데이터를 읽어오고 처리를 하게 되면 이미 그 사이에 데이터가 변경이 되었을 가능성이 높다.
- CQRS는 이런 변경 가능성을 인정하고 어차피 Read와 CUD 사이에는 delay가 존재할 수 있음을 인정하는 것이다.
- 이를 통해서 R과 CUD를 구분함으로써 얻는 이점을 설명하는 것이 CQRS패턴이다.

# CQRS를 사용하면 좋은 경우

- 여러 사용자가 동일한 데이터에 동시에 접근하는 공동 작업 도메인
- 복잡한 도메인 모델을 사용하는 복잡한 프로세스를 통해 사용자를 안내하는 작업 기반 사용자 인터페이스
  - 쓰기 모델에는 비즈니스 논리, 입력 유효성 검사 및 비즈니스 유효성 검사가 포함된 전체 명령 처리 스택이 있다 .
  - 쓰기 모델은 연결 된 개체 집합을 데이터 변경에 대 한 단일 단위로 취급할 수 있다. 즉, DDD 용어로 된 집계를 통해 이러한 개체가 항상 일관 된 상태에 있는지 확인할 수 있다.
  - 읽기 모델은 비즈니스 논리 또는 유효성 검사 스택이 없으며 뷰 모델에서 사용할 DTO가 반환된다. 결과적으로 읽기 모델과 쓰기 모델의 일관성이 유지된다.
- 데이터의 성능을 데이터 쓰기의 성능과 별도로 세부적으로 조정 해야 하는 시나리오는 특히 읽기 수가 쓰기 수보다 훨씬 많은 경우에 발생한다.
- 이 시나리오에서는 읽기 모델을 확장 하지만 몇 개의 인스턴스에서만 쓰기 모델을 실행할 수 있다.
- 소수의 쓰기 모델 인스턴스는 병합 충돌 발생을 최소화하는 데도 기여한다.
- 개발자 중 한 팀은 쓰기 모델에 포함되는 복잡한 도메인 모델에 집중하고 또 한 팀은 읽기 모델과 사용자 인터페이스에 집중할 수 있는 시나리오.
- 시스템이 시간이 지나면서 진화할 것으로 예상되어 여러 버전의 모델을 포함할 수 있거나 비즈니스 규칙이 정기적으로 변하는 시나리오
